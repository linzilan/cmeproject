/**
 * Document: MaxCompiler Tutorial (maxcompiler-tutorial)
 * Chapter: 4      Exercise: 1      Name: Simple Exercise
 * MaxFile name: SimpleExercise
 * Summary:
 * 	 Kernel that takes a stream and for each value x calculates x^2 + x.
 */
package simple;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath.Range;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFloat;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

class SimpleKernel extends Kernel
{
	DFEVar cdf(DFEVar z) {
	    //if (z > 6.0) { return 1.0; }; // this guards against overflow
	    //if (z < -6.0) { return 0.0; };
		DFEVar negative_chk = z > 6.0;
		DFEVar n;

		DFEVar b1 = constant.var(dfeFloat(8,24),0.31938153);
		DFEVar b2 = constant.var(dfeFloat(8,24),-0.356563782);
		DFEVar b3 = constant.var(dfeFloat(8,24),1.781477937);
		DFEVar b4 = constant.var(dfeFloat(8,24),-1.821255978);
		DFEVar b5 = constant.var(dfeFloat(8,24),1.330274429);
		DFEVar p = constant.var(dfeFloat(8,24),0.2316419);
		DFEVar c2 = constant.var(dfeFloat(8,24),0.3989423);
		DFEVar a=KernelMath.abs(z);
		DFEVar t = 1.0/(1.0+a*p);
		DFEVar b = c2*KernelMath.exp((-z)*(z/2.0));
		n = ((((b5*t+b4)*t+b3)*t+b2)*t+b1)*t;
	    n = 1.0-b*n;
	    negative_chk = z < 0.0;
	    n = negative_chk?1.0 - n:n;


		n = z > 6.0?1:z>-6.0?0:n;

	    return n;
	}

	DFEVar Black_Scholes(DFEVar S, DFEVar K, DFEVar r, DFEVar sigma, DFEVar time){
		KernelMath.Range log_range = new Range(-5,5);
	    DFEVar time_sqrt = KernelMath.sqrt(time);
	    DFEVar d1 = (KernelMath.log(log_range,S/K,dfeFloat(8,24))+r*time)/(sigma*time_sqrt) + 0.5*sigma*time_sqrt;
	    DFEVar d2 = d1-(sigma*time_sqrt);
	    return K*cdf(-r*time)*cdf(-d2) - S*cdf(-d1);


	}
	SimpleKernel(KernelParameters parameters) {
		super(parameters);

		DFEFloat double_type = dfeFloat(8,24);
		DFEVar S = io.scalarInput("parameter0", double_type);
		DFEVar X = io.scalarInput("parameter1", double_type);
		DFEVar r = io.scalarInput("parameter2", double_type);
		DFEVar b = io.scalarInput("parameter3", double_type);
		DFEVar sigma = io.scalarInput("parameter4",double_type);
		DFEVar time = io.scalarInput("parameter5", double_type);
		DFEVar ACCURACY = constant.var(double_type,0.0000001);
		KernelMath.Range log_range = new KernelMath.Range(-5, 5.0);

		DFEVar sigma_sqr = sigma*sigma;
		DFEVar  time_sqrt = KernelMath.sqrt(time);
		DFEVar  M=2.0*r/sigma_sqr;
		DFEVar  NN=2.0*b/sigma_sqr;
		DFEVar  K=1.0-KernelMath.exp(-r*time);
		DFEVar q1     = 0.5*(-(NN-1)-KernelMath.sqrt(KernelMath.pow2((NN-1), double_type)+(4.0*M/K)));

	    // now find initial S value
		DFEVar q1_inf = 0.5*(-(NN-1)-KernelMath.sqrt(KernelMath.pow2((NN-1),double_type)+4.0*M));
		DFEVar S_star_star_inf=X/(1.0-1.0/q1_inf);
		DFEVar h1 = (b*time-2*sigma*time_sqrt)*(X/(X-S_star_star_inf));
		DFEVar S_seed=S_star_star_inf+(X-S_star_star_inf)*KernelMath.exp(h1);

		DFEVar Si = S_seed;  // now do Newton iterations to solve for S**
		//DFEVar no_iterations = constant.var(double_type,0);
		DFEVar g          = constant.var(double_type,1);
		DFEVar gprime     = constant.var(double_type,1);

		for(int i=0;i<10;i++){
			 DFEVar check = KernelMath.abs(g)>ACCURACY;
			 check = check & KernelMath.abs(gprime)>ACCURACY;
			 check = check & (Si>0.0);

			 if(check == constant.var(true))break;

			 DFEVar p = Black_Scholes(Si,X,r,sigma,time);
			 DFEVar d1 = (KernelMath.log(log_range,Si/X,double_type)+(b+0.5*sigma_sqr)*time)/(sigma*time_sqrt);
				g = X - Si - p + (1-KernelMath.exp((b-r)*time)*cdf(-d1))*Si/q1;
				gprime = (1.0/q1-1.0)*(1.0-KernelMath.exp((b-r)*time)*cdf(-d1))
				    + (1.0/q1)*KernelMath.exp((b-r)*time)*(1.0/(sigma*time_sqrt))*cdf(-d1);
				Si=Si-(g/gprime);

		}

	    DFEVar S_star_star=Si;

	    DFEVar check2 = g>ACCURACY;

	    S_star_star = check2?S_seed:S_star_star;

	    DFEVar P=constant.var(double_type,0.0);
	    DFEVar p = Black_Scholes(S,X,r,sigma,time);

	    DFEVar check3 = S>S_star_star;

	    DFEVar d1 = (KernelMath.log(log_range,S_star_star/X,double_type)
			     + (b+0.5*sigma_sqr)*time)/(sigma*time_sqrt);
	    DFEVar A1 = -(S_star_star/q1)*(1-KernelMath.exp((b-r)*time)*cdf(-d1));
		P= p + A1 * KernelMath.exp(q1*KernelMath.log(log_range, S/S_star_star, double_type));//pow(x,n) = exp(n*ln(x))

	    P=check3?P:X-S;

		io.output("y", KernelMath.max(P,p), dfeFloat(8, 24));//return KernelMath.max(P,p);  // should not be lower than Black Scholes value

		/*
		//BS model
		 //double S, double X, double r, double q, double sigma, double time){
		 	//KernelMath km = new KernelMath();
		 	KernelMath.Range log_range = new KernelMath.Range(0.0,100.0);
		 		DFEVar d1 = KernelMath.log(log_range, S/K,dfeFloat(8, 24)) + (r-q+0.5*KernelMath.sqrt(sigma)*time)/(sigma*time); //log(S/X) + (r-q + 0.5*sigma_sqr)*time)/(sigma*time_sqrt);
			    DFEVar d2 =  d1-(sigma*KernelMath.sqrt(time));

			    //cdf of d1
			    DFEVar b1 = constant.var(double_type,0.31938153);
				DFEVar b2 = constant.var(double_type,-0.356563782);
				DFEVar b3 = constant.var(double_type,1.781477937);
				DFEVar b4 = constant.var(double_type,-1.821255978);
				DFEVar b5 = constant.var(double_type,1.330274429);
				DFEVar p = constant.var(double_type,0.2316419);
				DFEVar c2 = constant.var(double_type,0.3989423);
				DFEVar a = KernelMath.abs(d1);
				DFEVar t = 1.0/(1.0+a*p);
				DFEVar b = c2*KernelMath.exp((-d1)*(d1/constant.var(2.0)));
				d1 = ((((b5*t+b4)*t+b3)*t+b2)*t+b1)*t;
				d1 = 1.0-b*d1;

				//cdf d2
				 a = KernelMath.abs(d2);
				 t = 1.0/(1.0+a*p);
				 b = c2*KernelMath.exp((-d2)*(d2/2.0));
				 d2 = ((((b5*t+b4)*t+b3)*t+b2)*t+b1)*t;
				 d2 = 1.0-b*d2;

			    DFEVar call_price = S * KernelMath.exp(-q*time)* d1 - K * KernelMath.exp(-r*time) * d2;
		// Output
		io.output("y", call_price, dfeFloat(8, 24));*/
	}
}

